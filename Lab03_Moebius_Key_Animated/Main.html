<html>
  <head>
    <title>Boid simulation</title>
  </head>

  <style>
  body {margin: 0;}
  canvas {width: 100%; height: 100%;}
  </style>

  <body>
	<link rel="shortcut icon" href="#">

   
    <style>
    			body {
    				font-family: Monospace;
    				background-color: #000;
    				color: #fff;
    				margin: 0px;
    				overflow: hidden;
    			}
    			#info {
    				position: absolute;
    				top: 10px;
    				width: 100%;
    				text-align: center;
    			}
    </style>

    <div id="info">
      <p>This is the first example using threeJS<br>
      left button to rotate the scene, scroll to zoom in/out</p>
    </div>

		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js"
				}
			}
		</script>
		
	<script type="module">

  import * as THREE from 'three';
	import { OrbitControls } from './build/controls/OrbitControls.js'; 
     
    var scene = new THREE.Scene( );
    var ratio = window.innerWidth/window.innerHeight;
    var camera = new THREE.PerspectiveCamera(45,ratio,0.1,1000); 
    camera.position.set(0,0,-15);
	  camera.lookAt(0,0,1);
    
    var renderer = new THREE.WebGLRenderer( ); 
    renderer.setSize(window.innerWidth,window.innerHeight); 
    var renderer = new THREE.WebGLRenderer( );
    renderer.setSize(window.innerWidth,window.innerHeight);
    document.body.appendChild(renderer.domElement );

    var floorGeometry = new THREE.PlaneGeometry(100, 100, 10, 10);
    var floorMaterial = new THREE.MeshBasicMaterial({ color: 0x808080, side: THREE.DoubleSide });
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2; // Rotate the floor to be horizontal
    floor.position.set(0,-10,0);
    scene.add(floor);


  //////////////
	//   Boids  //
	//////////////

  class Boid{

    constructor(position, velocity, maxSpeed, maxForce, searchRadius, lightPoint, lightAttraction, scene) {
      //console.log("Initializing Boid");
        this.position = position; 
        this.velocity = velocity; 
        this.maxSpeed = maxSpeed; 
        this.maxForce = maxForce; 
        this.lightPoint = lightPoint;  
        this.lightAttraction = lightAttraction;
        this.searchRadius = searchRadius; 
        this.scene = scene;
        this.boidMesh = null; 
        this.acceleration = new THREE.Vector3();
        this.initBoidMesh();
    }

    update(){
        this.velocity.clampLength(0, this.maxSpeed);
        this.position.add(this.velocity);
        if (this.boidMesh) {
            //sets boid mesh position
            this.boidMesh.position.copy(this.position);
        }
    }

    boieRender(){
        //checks if boidMesh is not null and if this mesh is not already in the scene
        if (this.boidMesh && !this.scene.getObjectById(this.boidMesh.id)) {
            //if both are true, it adds the boid mesh to the scene
            this.scene.add(this.boidMesh);
        }
    }

    initBoidMesh() {
        // I'd reckon you can change the mesh of the moth here
        // I will use spheres to represent the moth

        const geometry = new THREE.SphereGeometry(1, 16, 16);
        const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        this.boidMesh = new THREE.Mesh(geometry, material);
        this.boidMesh.position.copy(this.position);
    }

    applyForce(force) {
            // Assume mass = 1 for simplicity
            this.velocity.add(force);
        }

    attractionToLight(){
        const lightAttractionForce = new THREE.Vector3().subVectors(this.lightPoint, this.position);
        lightAttractionForce.multiplyScalar(this.lightAttraction); 
        return lightAttractionForce;
    }

    avoidanceBehaviour(obstacles){
        let avoidanceForce = new THREE.Vector3(); 

        for (let obstacle of obstacles) {  
            if (obstacle !== this) { 
                var distance = this.position.distanceTo(obstacle.position);  
                if (distance < this.searchRadius) {  
                    var direction = new THREE.Vector3().subVectors(this.position, obstacle.position).normalize(); 
                    avoidanceForce.add(direction);  
                }
            }
        }

      return avoidanceForce;  
    }
  }

  class BoidManager {
      
      constructor(numberOfBoids, obstacles, velocity, maxSpeed, maxForce, searchRadius, lightPoint, lightAttraction, spawnRadius, scene) {
        //console.log("Initializing BoidManager");
          this.numberOfBoids = numberOfBoids;
          this.scene = scene;  
          this.boids = [];  
          this.obstacles = obstacles;

          this.velocity = velocity; 
          this.maxSpeed = maxSpeed; 
          this.maxForce = maxForce; 
          this.searchRadius = searchRadius; 
          this.lightPoint = lightPoint;  
          this.lightAttraction = lightAttraction; 
          this.spawnRadius = spawnRadius;
          
          for (let i = 0; i < this.numberOfBoids; i++) {
              let spawnPosition = new THREE.Vector3(
                this.getRandomInt(-this.spawnRadius, this.spawnRadius), 
                this.getRandomInt(-this.spawnRadius, this.spawnRadius), 
                this.getRandomInt(-this.spawnRadius, this.spawnRadius));

                const boidVelocity = new THREE.Vector3(
                this.getRandomFloat(-velocity, velocity),
                this.getRandomFloat(-velocity, velocity),
                this.getRandomFloat(-velocity, velocity)
            ).normalize().multiplyScalar(maxSpeed);

              const boid = new Boid(spawnPosition, boidVelocity, this.maxSpeed, 
                                      this.maxForce, this.searchRadius, 
                                      this.lightPoint, this.lightAttraction, this.scene);

              this.boids.push(boid);
          }
      }

      updateBoids() {
        console.log("Iterating over " + this.boids.length + " boids in update");

          for (const boid of this.boids) {
              this.obstacles.push(boid);
          }

          for (const boid of this.boids) {
              const lightAttractionForce = boid.attractionToLight();
              const avoidanceForce = boid.avoidanceBehaviour(this.obstacles);
              boid.applyForce(lightAttractionForce);
              boid.applyForce(avoidanceForce);
              boid.update();
              boid.boieRender();
          }
      }

        getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
    }


  }


  
  // Create boid manager
  //these paramters can be changed
  const numberOfBoids = 10;
    const obstacles = [];
    const velocity = 0.001;
    const maxSpeed = 0.005;
    const maxForce = 0.001;
    const searchRadius = 3;
    const lightPoint = new THREE.Vector3(0, 10, 0);
    const lightAttraction = 1;
    const spawnRadius = 10;
    const boidManager = new BoidManager(numberOfBoids, obstacles, velocity, maxSpeed, maxForce, searchRadius, lightPoint, lightAttraction, spawnRadius, scene);


  //////////////
	// CONTROLS //
	//////////////

  var controls = new OrbitControls( camera, renderer.domElement );

  var reverse=false;

  //final update loop
  var MyUpdateLoop = function ()
  {
    renderer.render(scene,camera);
    //console.log("Rendering loop");
    boidManager.updateBoids();
    controls.update();
    requestAnimationFrame(MyUpdateLoop);

  };
  requestAnimationFrame(MyUpdateLoop);

  
    function handleKeyDown(event) {
  
    }

  //add keyboard listener
  window.addEventListener('keydown', handleKeyDown, false);

  //this fucntion is called when the window is resized
  var MyResize = function ( )
  {
    var width = window.innerWidth;
    var height = window.innerHeight;
    renderer.setSize(width,height);
    camera.aspect = width/height;
    camera.updateProjectionMatrix();
    renderer.render(scene,camera);
  };

  //link the resize of the window to the update of the camera
  window.addEventListener( 'resize', MyResize);
    </script>
  </body>
</html>
